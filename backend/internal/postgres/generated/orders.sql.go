// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_name, user_phone_number, total_amount, status, shipping_address, payment_status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_name, user_phone_number, total_amount, status, shipping_address, payment_status, deleted_at, created_at
`

type CreateOrderParams struct {
	UserName        string         `json:"user_name"`
	UserPhoneNumber string         `json:"user_phone_number"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
	Status          string         `json:"status"`
	ShippingAddress string         `json:"shipping_address"`
	PaymentStatus   bool           `json:"payment_status"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserName,
		arg.UserPhoneNumber,
		arg.TotalAmount,
		arg.Status,
		arg.ShippingAddress,
		arg.PaymentStatus,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.Status,
		&i.ShippingAddress,
		&i.PaymentStatus,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE orders
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_name, user_phone_number, total_amount, status, shipping_address, payment_status, deleted_at, created_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.Status,
		&i.ShippingAddress,
		&i.PaymentStatus,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT id, user_name, user_phone_number, total_amount, status, shipping_address, payment_status, deleted_at, created_at FROM orders
WHERE 
    deleted_at IS NULL
    AND (
        $1::text IS NULL 
        OR status = $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListOrdersParams struct {
	Status        pgtype.Text `json:"status"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Status,
		arg.PaymentStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.UserPhoneNumber,
			&i.TotalAmount,
			&i.Status,
			&i.ShippingAddress,
			&i.PaymentStatus,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersCount = `-- name: ListOrdersCount :one
SELECT COUNT(*) FROM orders
WHERE 
    deleted_at IS NULL
    AND (
        $1::text IS NULL 
        OR status = $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
`

type ListOrdersCountParams struct {
	Status        pgtype.Text `json:"status"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
}

func (q *Queries) ListOrdersCount(ctx context.Context, arg ListOrdersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listOrdersCount, arg.Status, arg.PaymentStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET status = coalesce($1, status),
    payment_status = coalesce($2, payment_status)
WHERE id = $3
RETURNING id, user_name, user_phone_number, total_amount, status, shipping_address, payment_status, deleted_at, created_at
`

type UpdateOrderParams struct {
	Status        pgtype.Text `json:"status"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	ID            int64       `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.Status, arg.PaymentStatus, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.Status,
		&i.ShippingAddress,
		&i.PaymentStatus,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}
