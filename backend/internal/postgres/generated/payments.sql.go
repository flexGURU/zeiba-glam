// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payments.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (order_id, amount, transaction_id, payment_method, payment_status, paid_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, order_id, transaction_id, amount, payment_method, payment_status, paid_at, created_at
`

type CreatePaymentParams struct {
	OrderID       int64          `json:"order_id"`
	Amount        pgtype.Numeric `json:"amount"`
	TransactionID string         `json:"transaction_id"`
	PaymentMethod string         `json:"payment_method"`
	PaymentStatus bool           `json:"payment_status"`
	PaidAt        time.Time      `json:"paid_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.OrderID,
		arg.Amount,
		arg.TransactionID,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.PaidAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TransactionID,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT 
    p.id, p.order_id, p.transaction_id, p.amount, p.payment_method, p.payment_status, p.paid_at, p.created_at,
    o.id as "order_id",
    o.user_name as "order_user_name",
    o.user_phone_number as "order_user_phone_number", 
    o.total_amount as "order_total_amount",
    o.status as "order_status",
    o.shipping_address as "order_shipping_address",
    o.payment_status as "order_payment_status",
    o.created_at as "order_created_at"
FROM payments p
JOIN orders o ON o.id = p.order_id 
WHERE 
    (
      $1 IS NOT NULL AND id = $1
      OR
      $2 IS NOT NULL AND order_id = $2
    )
LIMIT 1
`

type GetPaymentParams struct {
	ID      interface{} `json:"id"`
	OrderID interface{} `json:"order_id"`
}

type GetPaymentRow struct {
	ID                   int64          `json:"id"`
	OrderID              int64          `json:"order_id"`
	TransactionID        string         `json:"transaction_id"`
	Amount               pgtype.Numeric `json:"amount"`
	PaymentMethod        string         `json:"payment_method"`
	PaymentStatus        bool           `json:"payment_status"`
	PaidAt               time.Time      `json:"paid_at"`
	CreatedAt            time.Time      `json:"created_at"`
	OrderID_2            int64          `json:"order_id_2"`
	OrderUserName        string         `json:"order_user_name"`
	OrderUserPhoneNumber string         `json:"order_user_phone_number"`
	OrderTotalAmount     pgtype.Numeric `json:"order_total_amount"`
	OrderStatus          string         `json:"order_status"`
	OrderShippingAddress string         `json:"order_shipping_address"`
	OrderPaymentStatus   bool           `json:"order_payment_status"`
	OrderCreatedAt       time.Time      `json:"order_created_at"`
}

func (q *Queries) GetPayment(ctx context.Context, arg GetPaymentParams) (GetPaymentRow, error) {
	row := q.db.QueryRow(ctx, getPayment, arg.ID, arg.OrderID)
	var i GetPaymentRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TransactionID,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.OrderID_2,
		&i.OrderUserName,
		&i.OrderUserPhoneNumber,
		&i.OrderTotalAmount,
		&i.OrderStatus,
		&i.OrderShippingAddress,
		&i.OrderPaymentStatus,
		&i.OrderCreatedAt,
	)
	return i, err
}

const getPaymentsOverviewByOrderID = `-- name: GetPaymentsOverviewByOrderID :many
SELECT id, order_id, transaction_id, amount, payment_method, payment_status, paid_at, created_at FROM payments WHERE order_id = $1
`

func (q *Queries) GetPaymentsOverviewByOrderID(ctx context.Context, orderID int64) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsOverviewByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.TransactionID,
			&i.Amount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many

SELECT id, order_id, transaction_id, amount, payment_method, payment_status, paid_at, created_at
FROM payments
WHERE 
    (
        $1::text IS NULL 
        OR payment_method = $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type ListPaymentsParams struct {
	PaymentMethod pgtype.Text `json:"payment_method"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

// -- name: GetPaymentByOrderID :one
// SELECT
//
//	p.*,
//	o.id as "order.id",
//	o.user_name as "order.user_name",
//	o.user_phone_number as "order.user_phone_number",
//	o.total_amount as "order.total_amount",
//	o.status as "order.status",
//	o.shipping_address as "order.shipping_address",
//	o.payment_status as "order.payment_status",
//	o.created_at as "order.created_at"
//
// FROM payments p
// JOIN orders o ON o.id = p.order_id
// WHERE p.order_id = $1;
func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.TransactionID,
			&i.Amount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsCount = `-- name: ListPaymentsCount :one
SELECT COUNT(*) AS total_payments
FROM payments 
WHERE 
    (
        $1::text IS NULL 
        OR payment_method = $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
`

type ListPaymentsCountParams struct {
	PaymentMethod pgtype.Text `json:"payment_method"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
}

func (q *Queries) ListPaymentsCount(ctx context.Context, arg ListPaymentsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listPaymentsCount, arg.PaymentMethod, arg.PaymentStatus)
	var total_payments int64
	err := row.Scan(&total_payments)
	return total_payments, err
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments 
SET payment_status = coalesce($1, payment_status), 
    paid_at = coalesce($2, paid_at)
WHERE id = $3
RETURNING id, order_id, transaction_id, amount, payment_method, payment_status, paid_at, created_at
`

type UpdatePaymentParams struct {
	PaymentStatus pgtype.Bool        `json:"payment_status"`
	PaidAt        pgtype.Timestamptz `json:"paid_at"`
	ID            int64              `json:"id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment, arg.PaymentStatus, arg.PaidAt, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TransactionID,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}
